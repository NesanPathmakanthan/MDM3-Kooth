import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics import normalized_mutual_info_score, adjusted_rand_score
import community.community_louvain as community_louvain

# Load the data
file_path = '/Users/isobelbridge/Documents/mdm4/simulated_kooth_data.csv'
df = pd.read_csv(file_path)

# CALCULATE WEIGHTING OF EDGES
# counting how many pieces of content of each topic each user has 
topic_counts = {user_id: {topic: 0 for topic in ["Anxiety", "Depression", "LGBTQ+", "Neurodiversity"]}
                for user_id in df['Service_User_ID'].unique()}
for _, row in df.iterrows():
    topic_counts[row['Service_User_ID']][row['Content_Topic']] += 1

# Convert topic counts to percentages
topic_distributions = {}
for user_id, counts in topic_counts.items():
    total = sum(counts.values())
    topic_distributions[user_id] = {topic: counts[topic] / total if total > 0 else 0 for topic in counts}

# Convert distributions to vectors for similarity calculation. similarity calculation = edge weighting
user_vectors = {user: np.array(list(distribution.values())) for user, distribution in topic_distributions.items()}

# BUILDING NETWORK
G_user = nx.DiGraph()
# add nodes for each user
for user_id in df['Service_User_ID'].unique():
    G_user.add_node(user_id)

# Add edges with weights based on topic distribution similarity
for _, row in df.iterrows():
    if not pd.isna(row['Ancestor_Content_ID']):  # Check for ancestor, this ancestor represents the node its connecting with 
        # Find the user (node) of the ancestor content
        ancestor_row = df[df['Content_Created_ID'] == row['Ancestor_Content_ID']]
        if not ancestor_row.empty:
            ancestor_user_id = ancestor_row.iloc[0]['Service_User_ID']
            current_user_id = row['Service_User_ID']
            
            # Compute cosine similarity between the topic distributions of the two users to calculate weight of edge
            similarity = cosine_similarity(
                user_vectors[current_user_id].reshape(1, -1),
                user_vectors[ancestor_user_id].reshape(1, -1)
            )[0, 0]
            
            # Add edge with weight
            if G_user.has_edge(current_user_id, ancestor_user_id):
                G_user[current_user_id][ancestor_user_id]['weight'] += similarity
            else:
                G_user.add_edge(current_user_id, ancestor_user_id, weight=similarity)

# IDENTIFYING PREDICTED COMMUNITIES
connected_nodes = {node for edge in G_user.edges() for node in edge}  # Nodes with at least one edge
G_connected = G_user.subgraph(connected_nodes)  # Subgraph with only connected nodes

# Perform community detection on the connected subgraph
partition = community_louvain.best_partition(G_connected.to_undirected(), weight='weight')

# IDENTIFYING ACTUAL COMMUNITIES (based on topics in fake generated data)
# getting label from the data for which community each user belongs to
ground_truth = {row['Service_User_ID']: row['Community_ID'] for _, row in df.iterrows() if row['Service_User_ID'] in connected_nodes}

# putting actual and predicted labels into a list so they can be compared and plotted
true_labels = []
predicted_labels = []

for user in G_connected.nodes():
    true_labels.append(ground_truth.get(user, -1))  # Use -1 for missing ground truth
    predicted_labels.append(partition.get(user, -1))  # Use -1 for missing prediction

# CALCULATING ACCURACY USING NMI (can't just use plain accuracy because it doesn't know how many communities to look for)
nmi = normalized_mutual_info_score(true_labels, predicted_labels)
print(f"Normalized Mutual Information (NMI): {nmi:.4f}")

# GRAPHING FULL NETWORK
plt.figure(figsize=(12, 6))
pos = nx.kamada_kawai_layout(G_connected)

# Plot 1: Ground Truth Communities
plt.subplot(1, 2, 1)
ground_truth_colors = [ground_truth.get(node, -1) for node in G_connected.nodes()]
nx.draw(
    G_connected,
    pos,
    with_labels=True,  # Disable node labels
    node_color=ground_truth_colors,
    cmap=plt.cm.tab10,  # Color map for communities
    node_size=600,  # Set node size to 50
    edge_color="gray" # Disable edges
)
plt.title("Actual Communities (Connected Nodes)", fontsize=16)

# Plot 2: Detected Communities
plt.subplot(1, 2, 2)
detected_colors = [partition.get(node, -1) for node in G_connected.nodes()]
nx.draw(
    G_connected,
    pos,
    with_labels=True,  # Disable node labels
    node_color=detected_colors,
    cmap=plt.cm.tab10,
    node_size=600,  # Set node size to 50
    edge_color="gray" # Disable edges
)
plt.title("Detected Communities (Louvain, Connected Nodes)", fontsize=16)

plt.tight_layout()
plt.show()

